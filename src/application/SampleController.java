package application;


import java.net.URL;
import java.util.HashSet;
import java.util.Random;
import java.util.ResourceBundle;

import javafx.animation.AnimationTimer;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;

public class SampleController extends AnimationTimer  implements Initializable{
	@FXML
	private Canvas canMain;
	@FXML
	private Button btnStart;
	@FXML
	private Button btnStop;
	@FXML
    private Canvas nBlockcan;
	@FXML
    private Label titleLabel;
	@FXML
    private Label nextBlockLabel;
	@FXML
    private Label scoreLabel;
	@FXML
    private Label scoreNum;
	@FXML
    private Button oneMoreBtn;
    @FXML
    private Button titleBtn;
    @FXML
    private Label gameOverLabel;
    @FXML
    private Button pRuleBtn;

	//ユーザ定義のフィールド(SceneBuilderで自動生成されないもの)
	HashSet<String> keyState;//押されているキーを登録
	GraphicsContext gc;//グラフィックコンテキスト(描画に必要)
	GraphicsContext nextGc;//グラフィックコンテキスト(描画に必要)
	final int width = 12;
	final int height = 22;
	int blockCnt = 0;
	boolean[] vec = new boolean[6];
	int[][] tetstage;//テトリス盤面
	int[][] block = {//現在操作しているブロック」
			{0,0,0,0},
			{0,0,0,0},
			{0,0,0,0},
			{0,0,0,0}
	};
	int[][] nextblock = {//次に操作するブロック」
			{0,0,0,0},
			{0,0,0,0},
			{0,0,0,0},
			{0,0,0,0}
	};
	int[][] wkblock = new int[4][4];

	/**
	 * downInterval ブロックが一段落ちる時間間隔 ナノ秒
	 */
	//final private long downInterval = 1000000000L;
	/**
	 * blockImage ブロックの画像を格納
	 * 0 背景
	 * 1～7 各ブロック
	 * 8 予備
	 * 9 壁
	 */
	Image[] blockImage = new Image[10];

	public int nowblock = 0;//現在操作中のブロックの番号
	public int nowblockPattern = 0;//現在操作中のブロックの向き
	public int nowblockprevPattern = 0;
	public int nextblocknum = 0;//次に操作するブロックの番号
	public boolean gameflag = true;
	private Animation banime;
	public int score = 0;
	public int scoreFloor = 100;
	public boolean scoreFlag = false;

	Random r = new Random();

	public boolean endflag = false;

	// Event Listener on Button[#btnStart].onAction
	@FXML
	public void onBtnStart(ActionEvent event) {

		// TODO Autogenerated
		gameStart();
		toGame();
		this.start();//描画開始(handleメソッドを１秒間に約60回呼び出しはじめる)

	}

	// Event Listener on Button[#btnStop].onAction
	@FXML
	public void onBtnStop(ActionEvent event) {
		// TODO Autogenerated
		this.stop();//描画停止(handleメソッドの呼び出しを止める)
	}
	@FXML
    void onOneMore(ActionEvent event) {
		gameStart();
		toGame();
		this.start();
    }

    @FXML
    void onTitle(ActionEvent event) {
    	toTitle();
    }
    @FXML
    void onRureBtn(ActionEvent event) {
    	Stage st = new Stage();
    	try {

			FXMLLoader fxLoader= new FXMLLoader(getClass().getResource("Rule.fxml"));
			AnchorPane root = (AnchorPane)fxLoader.load();
			Scene scene = new Scene(root,300,330);
			scene.getStylesheets().add(getClass().getResource("application.css").toExternalForm());

			st.setScene(scene);
			st.setTitle("テトリス");
			st.show();

		} catch(Exception e) {
			e.printStackTrace();
		}
    }


	/**
	 * 初期化メソッド　FXMLファイルがロードされたのち実行される
	 * Initializableをimplements(組み込み)する
	 */
	@Override
	public void initialize(URL location, ResourceBundle resources) {
		// TODO 自動生成されたメソッド・スタブ
		keyState = new HashSet<String>();
		gc = canMain.getGraphicsContext2D();
		nextGc = nBlockcan.getGraphicsContext2D();
		for(int i = 0;i < blockImage.length;i++) {
			blockImage[i] = new Image(Block.imgpath[i]);
		}
		toTitle();
	}


	/**
	 * 描画メソッド　startメソッド実行後、自動的に１秒間に約60回呼び出される
	 * 60fps(60フレーム/秒)
	 */
	@Override
	public void handle(long now) {
		// TODO 自動生成されたメソッド・スタブ
    	gc.clearRect(0, 0, canMain.getWidth(), canMain.getHeight());//canvas全体を消去
    	nextGc.clearRect(0, 0, nBlockcan.getWidth(), nBlockcan.getHeight());

    	banime.blockDisplay(gc, now);//盤面のブロックを表示

    	banime.nextBlockArea();//次のブロックを表示
    	if(banime.deleteAnimationFlag) {//ブロック消去アニメ中はここで終了
    		return;
    	}
    	if(banime.dropAnimationFlag) {//ブロックを落とすアニメ
    		if(scoreFlag) {//スコアを加算
    			score += banime.scoreCalc(banime.getDeleteLineCnt(), scoreFloor);
    			scoreFlag = false;
    		}
    		banime.dropAnimation(now);
    	}
    	if(endflag) {//終了判定
    		gameOver();
    		this.stop();
    	}
    	if(gameflag) banime.blockmove(now);
    	banime.downBlock(now);

    	banime.moveIntervalCheck(now);

    	banime.rotateIntervalCheck(now);

    	banime.sousablockDisplay(gc, now);
	}
	private int[][] makeblock(int blocknum) {//ブロックを生成
		return Block.blkPtrn[blocknum][0].clone();
	}
	private void nextBlockSet() {//次のブロックを生成
		nextblocknum = r.nextInt(7) + 1;
		nextblock = makeblock(nextblocknum);
	}
	public void changeBlock() {//次のブロックを操作するブロックにする
		nowblock = nextblocknum;
		block = nextblock.clone();
		nowblockPattern = 0;
		blockCnt++;
		scoreNum.setText(Integer.toString(score));
		nextBlockSet();
	}
	private void firstBlockSet() {//最初のブロックをセット
		nowblock = r.nextInt(7) + 1;
		block = makeblock(nowblock);
		nowblockPattern = 0;
		blockCnt++;
		nextBlockSet();
	}
	public void DeleteLineCheck() {//横一列に並んでいるかどうかチェック
		boolean flag,deleteflag;
		deleteflag = false;
		for(int i = 0;i < height - 1;i++) {//一列並んだ列があるか
			flag = true;
			for(int j = 1;j < width - 1;j++) {
				if(tetstage[i][j] == 0) {
					flag = false;
					break;
				}
			}
			if(flag) {
				deleteflag = true;
				banime.deleteAnimationYFlag[i] = true;
				banime.deleteAnimationFlag = true;
				banime.deleteCnt++;
			}
		}
		scoreFlag = deleteflag;
		banime.dropAnimationFlag = deleteflag;
	}
	private void gameStart() {
		firstBlockSet();
		initStage();
		banime = new Animation(this);
		score = 0;
		endflag = false;
		gameflag = true;
		this.scoreNum.setText(Integer.toString(score));
	}
	private void toTitle() {
		gc.clearRect(0, 0, canMain.getWidth(), canMain.getHeight());
    	nextGc.clearRect(0, 0, nBlockcan.getWidth(), nBlockcan.getHeight());
    	nextBlockLabel.setVisible(false);
    	gameOverLabel.setVisible(false);
		oneMoreBtn.setVisible(false);
		titleBtn.setVisible(false);
		titleLabel.setVisible(true);
		btnStart.setVisible(true);
		scoreLabel.setVisible(false);
		scoreNum.setVisible(false);
		pRuleBtn.setVisible(true);
	}
	private void toGame() {
		nextBlockLabel.setVisible(true);
    	gameOverLabel.setVisible(false);
		oneMoreBtn.setVisible(false);
		titleBtn.setVisible(false);
		titleLabel.setVisible(false);
		btnStart.setVisible(false);
		scoreLabel.setVisible(true);
		scoreNum.setVisible(true);
		pRuleBtn.setVisible(false);
	}
	private void gameOver() {
		nextGc.clearRect(0, 0, nBlockcan.getWidth(), nBlockcan.getHeight());
    	nextBlockLabel.setVisible(false);
		gameOverLabel.setVisible(true);
		oneMoreBtn.setVisible(true);
		titleBtn.setVisible(true);
	}
	/**
	 * キーが押されたら呼び出される(Main.javaで自力で登録)
	 * @param event
	 */
    public void onKeyPressed(KeyEvent event) {
//    	System.out.println(event.getCode()+"押した");
//    	keyState.add(event.getCode().toString());
    	if(event.getCode() == KeyCode.UP) {
    		this.vec[0] = true;
    		keyState.add(event.getCode().toString());
    	}
    	else if(event.getCode() == KeyCode.DOWN) {
    		this.vec[1] = true;
    		keyState.add(event.getCode().toString());
    	}
    	else if(event.getCode() == KeyCode.LEFT) {
    		this.vec[2] = true;
    		keyState.add(event.getCode().toString());
    	}
    	else if(event.getCode() == KeyCode.RIGHT) {
    		this.vec[3] = true;
    		keyState.add(event.getCode().toString());
    	}
    	if(event.getCode() == KeyCode.A) {
    		this.vec[4] = true;
    		keyState.add(event.getCode().toString());
    	}
    	else if(event.getCode() == KeyCode.F) {
    		this.vec[5] = true;
    		keyState.add(event.getCode().toString());
    	}
    }

   /**
    * キーが離されたら呼び出される(Main.javaで自力で登録)
    * @param event
    */
    public void onKeyReleased(KeyEvent event) {
    	if(event.getCode() == KeyCode.UP) {
    		this.vec[0] = false;
    		keyState.remove(event.getCode().toString());
    	}
    	else if(event.getCode() == KeyCode.DOWN) {
    		this.vec[1] = false;
    		keyState.remove(event.getCode().toString());
    	}
    	else if(event.getCode() == KeyCode.LEFT) {
    		this.vec[2] = false;
    		keyState.remove(event.getCode().toString());
    	}
    	else if(event.getCode() == KeyCode.RIGHT) {
    		this.vec[3] = false;
    		keyState.remove(event.getCode().toString());
    	}
    	if(event.getCode() == KeyCode.A) {
    		this.vec[4] = false;
    		keyState.remove(event.getCode().toString());
    	}
    	else if(event.getCode() == KeyCode.F) {
    		this.vec[5] = false;
    		keyState.remove(event.getCode().toString());
    	}
    }
    private void initStage() {
    	tetstage = new int[height + 2][width + 1];
    	int i;
    	for(i = 0;i < height;i++) {
    		tetstage[i][0] = 9;
    		tetstage[i][11] = 9;
    	}
    	for(i = 0;i < width;i++) {
    		tetstage[21][i] = 9;
    	}
    }
}
